### 介绍
+ 传统的 JavaScript 程序使用函数和基于原型的继承来创建可重用的组件，但对于熟悉使用面向对象方式的程序员来讲就有些棘手，因为他们用的是基于类的继承并且对象是由类构建出来的
+ 从 ECMAScript 2015，也就是 ECMAScript 6 开始，JavaScript 程序员将能够使用基于类的面向对象的方式
+ 使用 TypeScript，允许开发者现在就使用这些特性，并且编译后的JavaScript 可以在所有主流浏览器和平台上运行，而不需要等到下个JavaScript 版本

### 类
+ 声明类：class Person {}
+ 使用类：let person = new Person()

### 继承
+ 使用继承来扩展现有的类
+ 通过 extends 关键字
+ 派生类通常被称作子类，基类通常被称作超类（父类）
+ 派生类构造函数里访问 this 的属性之前，一定要调用 super()
+ 在子类里可以重写父类的方法，可以通过 super.方法名() 调用父类的方法

### 公共、私有与受保护的修饰符
+ 在 TypeScript 里，成员都默认为 public
+ private 不能在声明它的类的外部访问
+ protected 成员在派生类中可以访问，不能在声明它的类的外部访问
+ 注意：TypeScript 使用的是**结构性类型系统**
  + 比较两种不同的类型时，并不在乎它们从何处而来，如果所有成员的类型都是兼容的，就认为它们的类型是兼容的
  + 比较带有 private 或 protected 成员的类型时，情况就不同了：
    + 如果其中一个类型包含一个 private 成员，那么只有当另外一个类型也存在这样一个 private 成员，并且这些成员都是来自同一处声明时，才认为这两个类型是兼容的
    + 对于 protected 成员也使用如上规则

### readonly 修饰符
+ 可以使用 readonly 关键字将属性设置为只读的
+ 只读属性必须在声明时或构造函数里被初始化

### 参数属性
+ 可以方便地让我们在一个地方定义并初始化一个成员
+ 通过给构造函数参数前面添加一个访问限定符来声明

```ts
class People {
  readonly sex: string = '女';
  constructor(
    readonly name: string,
    public height: string,
    private weight: string
  ) { }
}
```

### 存储器
+ TypeScript 支持通过 getters/setters 来截取对对象成员的访问
+ 能帮助你有效的控制对对象成员的访问